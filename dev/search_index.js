var documenterSearchIndex = {"docs":
[{"location":"Vignette-Recommender/#Recommender-Vignette","page":"Recommender Vignette","title":"Recommender Vignette","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"using IteratedProcessSimulations\nusing Recommendation\nusing DataFrames\nusing Soss\nusing MeasureTheory\nusing Chain\nusing DataFrameMacros\nusing UUIDs\nusing VegaLite\nimport Distributions","category":"page"},{"location":"Vignette-Recommender/#Simulation-Premises","page":"Recommender Vignette","title":"Simulation Premises","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"A bookstore has customer account data on previous purchases as well as a monthly newsletter in which it can suggest three books to read, personalized to each customer.","category":"page"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"All books cost the same. Each book has latent attributes, quality and topicality, which are fixed. Each customer has unique preferences weighting these two factors and resulting in a utility score. The customer chooses the highest utility book each month, as long as it has a utility greater than 0 (the utility of the most attractive non-book good available and average score across all books and attributes).","category":"page"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"New books are released each month. The bookstore uses a collaborative filter to identify optimal books to offer to each user. Once a user has chosen a book, its user-specific utility becomes visible to the bookstore (i.e. a rating).","category":"page"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"To gather feedback on newly released books, the bookstore distributes copies to 10% of users in the release month, in exchange for their rating which becomes available instantly.","category":"page"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"The simulation runs over a course of 36 months.","category":"page"},{"location":"Vignette-Recommender/#Simulate-User-Preferences","page":"Recommender Vignette","title":"Simulate User Preferences","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"n_users = 100\nn_books_per_month = 10\nn_months = 24\npct_pre_read = 0.1  # X% of new books are 'pre-read' by users\n\n# Define data generating process for the users\nuser_dgp = @model params begin\n        user_utility_weight_quality ~ Distributions.TruncatedNormal(0.5, 0.1, 0, 1)\n        user_utility_weight_topicality = 1 - user_utility_weight_quality\nend\n\nuser_sim_description = DataFrame(\n    \"n_datapoints\" => [n_users],\n    \"epoch\" => [0],\n)","category":"page"},{"location":"Vignette-Recommender/#Create-user-sample","page":"Recommender Vignette","title":"Create user sample","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"user_attributes = @chain generate_data(user_dgp, user_sim_description) begin\n    @transform(:user_id = @c 1:length(:id))\n    @select(:user_id, :user_utility_weight_quality, :user_utility_weight_topicality)\nend\n\nfirst(user_attributes, 4)","category":"page"},{"location":"Vignette-Recommender/#Define-data-generating-process-for-the-books","page":"Recommender Vignette","title":"Define data generating process for the books","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"book_dgp = @model params begin\n        quality ~ Distributions.TruncatedNormal(10, 3, 0, 100)\n        topicality ~ Distributions.TruncatedNormal(10, 3, 0, 100)\nend\n\nbook_sim_description = DataFrame(\n    \"n_datapoints\" => fill(n_books_per_month, 36),\n    \"epoch\" => 1:36,\n)\n\n# TODO: remove line, just for testing\nbook_attributes = generate_data(book_dgp, eachrow(book_sim_description)[2])\n\nfirst(book_attributes, 4)","category":"page"},{"location":"Vignette-Recommender/#Build-user-book-dataframe-via-transform_data-function","page":"Recommender Vignette","title":"Build user-book dataframe via transform_data function","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"function transform_data(book_df)\n\n    book_df = @chain book_df @transform(:book_id = @c 1:nrow(book_df)) @transform(:book_id = :book_id + (:epoch - 1) * nrow(book_df))\n    user_book_df = @chain book_df begin\n        crossjoin(user_attributes)\n    end\n\n    user_book_df = @chain user_book_df begin\n        @transform(\n            :user_book_utility = :topicality * :user_utility_weight_topicality + :quality * :user_utility_weight_quality,\n            # X% of new books are 'pre-read' by users\n            :pre_read = rand(Bernoulli(pct_pre_read))\n                   )\n    end\n\n    user_book_df[!, :predicted_utility] .= missing\n    user_book_df[!, :predicted_utility] = convert(Vector{Union{Missing, Float64}}, user_book_df[!, :predicted_utility])\n\n    return user_book_df\nend\n\n# TODO: remove line, just for testing\nnew_data = transform_data(book_attributes)\n\nfirst(new_data, 4)","category":"page"},{"location":"Vignette-Recommender/#Define-Machine-Learning-Model","page":"Recommender Vignette","title":"Define Machine Learning Model","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"# TODO: remove line, just for testing\ntraining_data = new_data\n\nfunction convert_dataframe_to_recommender(df::DataFrame, n_users, n_books)\n    event_list = []\n    for row in eachrow(df)\n        # Here we assume that a user knows and reports their utility after having read the book\n        push!(event_list, Event(row[:user_id], row[:book_id], row[:user_book_utility]))\n    end\n\n    event_list = convert(Vector{Event}, event_list)\n    \n    data = DataAccessor(event_list, n_users, n_books)\n\n    return data\nend\n\nfunction fit_model(epoch_parameters::DataFrameRow, training_data::DataFrame, new_data::DataFrame)\n        # Note, the statement below permanently adds the new data to the training dataset\n        append!(training_data, new_data, promote=true)\n\n        n_users = maximum(training_data[!, :user_id])\n        n_books = maximum(training_data[!, :book_id])\n        # Drop unobserved outcomes\n        training_data = @chain training_data @subset(:observed | :pre_read)\n            \n\n        data = convert_dataframe_to_recommender(training_data, n_users, n_books)\n        recommender = SVD(data, 10)\n        build!(recommender)\n\n        return recommender\nend\n\nfit_model(eachrow(book_sim_description)[1], training_data, new_data)","category":"page"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"# Skip using this to track parameter / model outcomes for now, but could be useful in a real study...\nfunction summarize_model(epoch_parameters::DataFrameRow, model, simulation_data::DataFrame, new_data::DataFrame)\n    DataFrame(:epoch => [epoch_parameters.epoch])\nend","category":"page"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"function choose_observations(epoch_parameters::DataFrameRow, recommender, new_data::DataFrame, simulation_data::DataFrame)\n    # NOTE: as the new_data is already added to the simulation data during the model fit, no need to use `new_data` here\n\n    # Each user gets to read an additional book!\n    for user_id in unique((@chain simulation_data @subset(!(:observed | :pre_read)) _[!, :user_id]))\n        user_prediction = recommend(recommender, user_id, 1, (@chain simulation_data @subset(!(:observed | :pre_read) & (:user_id == user_id)) @select(:book_id) unique _[!, :book_id]))\n        best_book = user_prediction[1][1]\n        best_book_score = user_prediction[1][2]\n        simulation_data[((simulation_data[!, :user_id] .== user_id) .& (simulation_data[!, :book_id] .== best_book)), :observed] .= true\n        simulation_data[((simulation_data[!, :user_id] .== user_id) .& (simulation_data[!, :book_id] .== best_book)), :predicted_utility] .= best_book_score\n    end\n\n    return simulation_data\nend\t","category":"page"},{"location":"Vignette-Recommender/#Put-it-all-together-and-run-the-simulation","page":"Recommender Vignette","title":"Put it all together and run the simulation","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"ips = IteratedProcessSimulation(book_dgp, book_sim_description, transform_data, fit_model, summarize_model, choose_observations)\n\nsimulation_data, model_summary, model_objects = run_simulation(ips)\n\n# TODO: for debugging, remove\nuser_id = 1\nrecommender = model_objects[36]","category":"page"},{"location":"Vignette-Recommender/#Assess-outcome-quality","page":"Recommender Vignette","title":"Assess outcome quality","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup = @chain simulation_data begin\n    @groupby(:user_id, :user_utility_weight_quality, :user_utility_weight_topicality)\n    @combine(:user_utility_achieved = sum(:user_book_utility[:observed]), # may be negative if pos-predicted utility turns out to be negative\n             :user_utility_predicted = sum(:predicted_utility[:observed]), # this should be strictly positive\n             :user_utility_possible = @c sum(filter(x -> x > 0, sort(:user_book_utility, rev=true)[1:n_months])) # user has the possibility of choosing X books = n_months\n             ) \n    @transform(:pct_utility_achieved = :user_utility_achieved / :user_utility_possible)\nend\n\nfirst(utility_rollup, 6)","category":"page"},{"location":"Vignette-Recommender/#Plot-Utility-Distribution-across-Users","page":"Recommender Vignette","title":"Plot Utility Distribution across Users","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup |> @vlplot(:bar, width=500, height=300, x={:user_utility_achieved, bin={step=0.5}, title=\"Total Utility Achieved\"}, y={\"count()\", title=\"User Count\"}, title=\"Utility Achieved per User\")","category":"page"},{"location":"Vignette-Recommender/#Plot-Predicted-Utility-vs-Actual-Utility","page":"Recommender Vignette","title":"Plot Predicted Utility vs Actual Utility","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup |> @vlplot(:point, width=500, height=500, x={:user_utility_achieved, title=\"Total Utility Achieved\"}, y={:user_utility_possible, title=\"Total Utility Possible\"}, title=\"Model Relatively Ineffective\")","category":"page"},{"location":"Vignette-Recommender/#Plot-Percent-Utility-Achieved-across-Users","page":"Recommender Vignette","title":"Plot Percent Utility Achieved across Users","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup |> @vlplot(width=500, height=300, :bar, x={:pct_utility_achieved, bin={step=0.005}, title=\"Percent Utility Achieved\", axis={format=\"%\"}}, y={\"count()\", title=\"User Count\"}, title=\"Percentage of Possible Utility Achieved per User\")","category":"page"},{"location":"Vignette-Recommender/#Plot-User-Preferences","page":"Recommender Vignette","title":"Plot User Preferences","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup |> @vlplot(width=500, height=300, :bar, x={:user_utility_weight_quality, bin={step=0.05}, title=\"User Preference for Quality (over Topicality)\", axis={format=\"%\"}}, y={\"count()\", title=\"User Count\"}, title=\"User Preferences, Percentage Weight Quality (vs Topicality)\")","category":"page"},{"location":"Vignette-Recommender/#Plot-Individual-Preferences-Against-Total-Utility-Possible","page":"Recommender Vignette","title":"Plot Individual Preferences Against Total Utility Possible","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup |> @vlplot(width=500, height=300, :bar, x={:user_utility_weight_quality, bin={step=0.01}, title=\"User Preference for Quality (over Topicality)\", axis={format=\"%\"}}, y={\"mean(user_utility_possible)\", title=\"Possible Utility\"}, title=\"Possible Utility by User Preferences\")","category":"page"},{"location":"Vignette-Recommender/#Plot-Individual-Preferences-Against-Utility","page":"Recommender Vignette","title":"Plot Individual Preferences Against Utility","text":"","category":"section"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup |> @vlplot(width=500, height=300, :bar, x={:user_utility_weight_quality, bin={step=0.01}, title=\"User Preference for Quality (over Topicality)\", axis={format=\"%\"}}, y={\"mean(pct_utility_achieved)\", title=\"Average Percent Utility Achieved\", axis={format=\"%\"}}, title=\"Percentage of Possible Utility Achieved by User Preferences\")","category":"page"},{"location":"Vignette-Recommender/","page":"Recommender Vignette","title":"Recommender Vignette","text":"utility_rollup |> @vlplot(width=500, height=300, :bar, x={:user_utility_weight_quality, bin={step=0.01}, title=\"User Preference for Quality (over Topicality)\", axis={format=\"%\"}}, y={\"mean(user_utility_achieved)\", title=\"Average Utility Achieved\"}, title=\"Average Utility Achieved by User Preferences\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = IteratedProcessSimulations","category":"page"},{"location":"#IteratedProcessSimulations","page":"Home","title":"IteratedProcessSimulations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for IteratedProcessSimulations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [IteratedProcessSimulations]","category":"page"},{"location":"#IteratedProcessSimulations.IteratedProcessSimulation","page":"Home","title":"IteratedProcessSimulations.IteratedProcessSimulation","text":"IteratedProcessSimulation(data_generating_process, simulation_description, fit_model, summarize_model, choose_observations)\n\nA type which collects all elements necessary to run an iterated simulation of a machine learning process.\n\nThe following attributes must be supplied:\n\n\n\n\n\n","category":"type"},{"location":"#IteratedProcessSimulations.generate_data-Tuple{Soss.Model, DataFrames.DataFrameRow}","page":"Home","title":"IteratedProcessSimulations.generate_data","text":"generate_data(data_generating_process::Soss.Model, epoch_parameters::DataFrameRow)\n\nGenerate data from a data_generating_process for a single epoch.\n\n\n\n\n\n","category":"method"},{"location":"#IteratedProcessSimulations.generate_data-Tuple{Soss.Model, DataFrames.DataFrame}","page":"Home","title":"IteratedProcessSimulations.generate_data","text":"generate_data(data_generating_process::Soss.Model, epoch_parameters::DataFrame)\n\nGenerate data from a data_generating_process for a series of epochs.\n\n\n\n\n\n","category":"method"},{"location":"#IteratedProcessSimulations.run_simulation-Tuple{IteratedProcessSimulation, Int64}","page":"Home","title":"IteratedProcessSimulations.run_simulation","text":"run_simulation(ips::IteratedProcessSimulation, n_simulations::Int)\n\nRun an iterated process simulation n_simulations times.\n\n\n\n\n\n","category":"method"},{"location":"#IteratedProcessSimulations.run_simulation-Tuple{IteratedProcessSimulation}","page":"Home","title":"IteratedProcessSimulations.run_simulation","text":"run_simulation(ips::IteratedProcessSimulation)\n\nRun a single iterated process simulation.\n\n\n\n\n\n","category":"method"},{"location":"#IteratedProcessSimulations.validate_inputs-Tuple{IteratedProcessSimulation}","page":"Home","title":"IteratedProcessSimulations.validate_inputs","text":"validate_inputs(ips::IteratedProcessSimulation)\n\nValidate IteratedProcessSimulation object.\n\n\n\n\n\n","category":"method"},{"location":"#IteratedProcessSimulations.validate_simulation_description-Tuple{DataFrames.DataFrame}","page":"Home","title":"IteratedProcessSimulations.validate_simulation_description","text":"Check whether simulation_description dataframe is properly specified with n_datapoints column for i.i.d. sampling from data generating process\n\n\n\n\n\n","category":"method"}]
}
